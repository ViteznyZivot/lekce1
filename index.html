<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bay Street OS: Web3 Protocol</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">

    <style>
        /* --- VISUAL IDENTITY: BAY STREET ELECTRIC --- */
        :root {
            --bg-deep: #020617; /* Slate 950 */
            --cyan-electric: #00f0ff;
            --cyan-dim: #0891b2;
            --blue-neon: #3b82f6;
            --error-red: #ff2a6d;
            --success-green: #05ffa1;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-deep);
            color: #e2e8f0;
            overflow: hidden; /* We handle scroll manually/programmatically */
            margin: 0;
            cursor: crosshair;
        }

        h1, h2, h3, .brand-font {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* --- CANVAS --- */
        #main-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 0;
            background: radial-gradient(circle at 50% 50%, #0f172a 0%, #020617 80%);
        }

        /* --- UI OVERLAY --- */
        #ui-layer {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass to canvas when needed */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .pointer-events-auto { pointer-events: auto; }

        /* --- ELEMENTS --- */
        .glass-panel {
            background: rgba(2, 6, 23, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 240, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.1);
        }

        .neon-text {
            text-shadow: 0 0 10px var(--cyan-electric);
            color: var(--cyan-electric);
        }
        
        .neon-border {
            box-shadow: 0 0 15px var(--cyan-electric), inset 0 0 10px var(--cyan-electric);
            border-color: var(--cyan-electric);
        }

        .input-glow {
            background: transparent;
            border: none;
            border-bottom: 2px solid var(--cyan-dim);
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            text-align: center;
            outline: none;
            transition: all 0.3s;
        }
        .input-glow:focus {
            border-bottom-color: var(--cyan-electric);
            text-shadow: 0 0 15px var(--cyan-electric);
        }

        /* --- PHASE TRANSITIONS --- */
        .phase-content {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
            position: absolute;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
        }
        .phase-content.active {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }
        .phase-content.hidden-left {
            opacity: 0;
            transform: translateX(-100px);
        }
        .phase-content.hidden-right {
            opacity: 0;
            transform: translateX(100px);
        }

        /* --- LEVER --- */
        .lever-container {
            width: 60px; height: 150px;
            background: #0f172a;
            border: 2px solid #334155;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
        }
        .lever-track {
            width: 10px; height: 120px;
            background: #000;
            margin: 15px auto;
            border-radius: 5px;
        }
        .lever-handle {
            width: 40px; height: 30px;
            background: var(--cyan-dim);
            position: absolute;
            left: 10px; top: 10px;
            border-radius: 4px;
            transition: top 0.2s cubic-bezier(0.4, 2.5, 0.55, 0.5); /* Bouncy */
            box-shadow: 0 0 10px var(--cyan-electric);
        }
        .lever-handle.pulled {
            top: 110px;
            background: var(--success-green);
            box-shadow: 0 0 15px var(--success-green);
        }

        /* --- ANIMATIONS --- */
        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        .scan-overlay {
            position: fixed; top: 0; left: 0; w-full; h-full;
            background: linear-gradient(to bottom, transparent, rgba(0, 240, 255, 0.05), transparent);
            z-index: 5; pointer-events: none;
            height: 100vh; width: 100vw;
            animation: scanline 8s linear infinite;
        }

    </style>
</head>
<body>

    <canvas id="main-canvas"></canvas>
    <div class="scan-overlay"></div>

    <!-- HUD -->
    <div class="fixed top-0 left-0 w-full p-6 flex justify-between items-center z-50 pointer-events-none mix-blend-screen">
        <div class="flex items-center gap-2">
            <i data-lucide="cpu" class="text-cyan-400 w-5 h-5 animate-pulse"></i>
            <span class="font-mono text-xs text-cyan-400">SYS.BSV.3.0 // ONLINE</span>
        </div>
        <div class="flex flex-col items-end">
            <span class="font-mono text-xs text-gray-500" id="user-identity">GUEST_USER</span>
            <div class="h-1 w-32 bg-gray-800 mt-1 rounded overflow-hidden">
                <div id="progress-bar" class="h-full bg-cyan-400 w-0 transition-all duration-500"></div>
            </div>
        </div>
    </div>

    <!-- UI LAYER -->
    <div id="ui-layer">

        <!-- PHASE 0: IDENTITY -->
        <div id="phase-0" class="phase-content active flex-col items-center">
            <h1 class="text-5xl font-black mb-8 text-white tracking-widest text-center">INITIALIZE<br><span class="text-cyan-400">IDENTITY</span></h1>
            <div class="relative group">
                <input type="text" id="username-input" class="input-glow pointer-events-auto w-64 uppercase" placeholder="ENTER NAME" autocomplete="off" maxlength="12">
                <div class="absolute -bottom-8 left-0 w-full text-center text-xs text-gray-500 font-mono opacity-0 group-hover:opacity-100 transition-opacity">
                    PRESS ENTER TO GENERATE CRYSTAL
                </div>
            </div>
        </div>

        <!-- PHASE 1: THE FALL (BANK) -->
        <div id="phase-1" class="phase-content flex-col items-center">
            <div class="absolute top-20 text-center pointer-events-none">
                <h2 class="text-3xl font-bold text-white mb-2">SYSTEM: CENTRALIZED</h2>
                <p class="text-gray-400 text-sm font-mono">TASK: BYPASS THE INTERMEDIARY</p>
            </div>
            
            <!-- Draggable Orb Target Zone (Invisible logic handled by canvas/js, visual hint here) -->
            <div class="absolute bottom-20 text-cyan-400 text-xs font-mono animate-bounce">
                DRAG THE ORB
            </div>
        </div>

        <!-- PHASE 2: THE FORGE -->
        <div id="phase-2" class="phase-content flex-col items-center w-full max-w-4xl">
            <div class="flex gap-12 items-center pointer-events-auto">
                <!-- Data Slot -->
                <div class="glass-panel p-8 rounded-xl w-64 h-64 flex flex-col items-center justify-center gap-4 relative" id="data-slot">
                    <div class="text-xs text-cyan-500 font-mono mb-4 absolute top-4">DATA INPUT</div>
                    <div class="grid grid-cols-1 gap-2 w-full">
                        <div class="bg-gray-800/50 p-2 border border-gray-600 rounded text-xs text-center cursor-move hover:border-cyan-400 transition-colors draggable-tx">TX: ALICE -> BOB</div>
                        <div class="bg-gray-800/50 p-2 border border-gray-600 rounded text-xs text-center cursor-move hover:border-cyan-400 transition-colors draggable-tx">TX: 500 USDC</div>
                        <div class="bg-gray-800/50 p-2 border border-gray-600 rounded text-xs text-center cursor-move hover:border-cyan-400 transition-colors draggable-tx" contenteditable="true" oninput="breakHash()">METADATA: TIME</div>
                    </div>
                </div>

                <!-- Arrow -->
                <i data-lucide="arrow-right" class="text-gray-600 w-8 h-8"></i>

                <!-- The Lever -->
                <div class="flex flex-col items-center gap-4">
                    <div class="lever-container" onclick="pullLever()">
                        <div class="lever-track"></div>
                        <div id="forge-lever" class="lever-handle"></div>
                    </div>
                    <span class="text-xs text-gray-500 font-mono">HASH</span>
                </div>

                <!-- Arrow -->
                <i data-lucide="arrow-right" class="text-gray-600 w-8 h-8"></i>

                <!-- Result -->
                <div class="glass-panel p-8 rounded-xl w-64 h-64 flex items-center justify-center relative">
                    <div class="text-xs text-cyan-500 font-mono mb-4 absolute top-4">BLOCK HASH</div>
                    <div id="hash-display" class="font-mono text-xs text-gray-500 break-all text-center">WAITING_FOR_INPUT...</div>
                </div>
            </div>
            <div class="mt-8 text-gray-500 text-xs font-mono">EDIT DATA TO BREAK GEOMETRY</div>
            
            <button class="mt-8 pointer-events-auto px-6 py-2 border border-cyan-500/30 text-cyan-400 hover:bg-cyan-500/10 transition-colors rounded uppercase font-bold text-sm tracking-widest hidden" id="phase-2-next" onclick="nextPhase()">
                Proces dokončen. Pokračovat.
            </button>
        </div>

        <!-- PHASE 3: THE CHAIN -->
        <div id="phase-3" class="phase-content flex-col items-center">
            <div class="absolute top-20 text-center pointer-events-none">
                <h2 class="text-3xl font-bold text-white mb-2">IMMUTABILITY LINK</h2>
                <p class="text-gray-400 text-sm font-mono">TRY TO HACK BLOCK #005</p>
            </div>
            <button class="absolute bottom-20 pointer-events-auto px-6 py-2 border border-cyan-500/30 text-cyan-400 hover:bg-cyan-500/10 transition-colors rounded uppercase font-bold text-sm tracking-widest hidden" id="phase-3-next" onclick="nextPhase()">
                Zabezpečení ověřeno. Pokračovat.
            </button>
        </div>

        <!-- PHASE 4: CONSENSUS -->
        <div id="phase-4" class="phase-content flex-col items-center">
            <div class="absolute top-20 text-center pointer-events-none">
                <h2 class="text-3xl font-bold text-white mb-2">GLOBAL CONSENSUS</h2>
                <p class="text-gray-400 text-sm font-mono">BROADCASTING NEW BLOCK...</p>
            </div>
            <button class="pointer-events-auto mt-96 px-8 py-3 bg-cyan-500 text-black font-bold text-lg rounded shadow-[0_0_20px_#00f0ff] hover:scale-105 transition-transform" onclick="broadcastBlock()">
                BROADCAST SIGNAL
            </button>
        </div>

        <!-- PHASE 5: SMART CONTRACT -->
        <div id="phase-5" class="phase-content flex-col items-center">
             <div class="glass-panel p-10 rounded-xl relative pointer-events-auto">
                 <h2 class="text-2xl font-bold text-white mb-6 text-center border-b border-gray-700 pb-4">LOGIC GATE: PAYMENT</h2>
                 <div class="flex justify-between items-center gap-16">
                     <!-- Input -->
                     <div class="text-center">
                         <div class="w-16 h-16 bg-gray-800 rounded-full border-2 border-gray-600 flex items-center justify-center mb-2" id="sc-input">
                             <i data-lucide="coins" class="text-gray-400 w-8 h-8"></i>
                         </div>
                         <button class="text-xs px-3 py-1 bg-gray-700 hover:bg-cyan-600 text-white rounded transition-colors mt-2" onclick="triggerSmartContract()">SEND 50 ETH</button>
                     </div>
                     
                     <!-- Logic -->
                     <div class="relative w-32 h-1 bg-gray-700">
                         <div id="sc-signal" class="h-full bg-cyan-400 w-0 transition-all duration-1000"></div>
                         <div class="absolute -top-6 left-1/2 transform -translate-x-1/2 text-[10px] text-cyan-500 font-mono bg-black px-1">IF PAID == TRUE</div>
                     </div>

                     <!-- Output -->
                     <div class="text-center">
                         <div class="w-16 h-16 bg-gray-800 rounded-lg border-2 border-red-500 flex items-center justify-center mb-2 shadow-[0_0_15px_#ff2a6d]" id="sc-output">
                             <i data-lucide="lock" class="text-red-500 w-8 h-8" id="sc-lock-icon"></i>
                         </div>
                         <span class="text-xs text-gray-500" id="sc-status">LOCKED</span>
                     </div>
                 </div>
             </div>
             <button class="mt-12 pointer-events-auto px-6 py-2 border border-cyan-500/30 text-cyan-400 hover:bg-cyan-500/10 transition-colors rounded uppercase font-bold text-sm tracking-widest hidden" id="phase-5-next" onclick="nextPhase()">
                Vstup povolen. Brána Web3.
            </button>
        </div>

        <!-- PHASE 6: NFT/OWNERSHIP -->
        <div id="phase-6" class="phase-content flex-col items-center">
            <h1 class="text-6xl font-black mb-4 text-white tracking-widest text-center">WEB3 <span class="text-green-400">ACCESS</span></h1>
            <p class="text-gray-400 mb-12 font-mono">GENESIS TOKEN MINTED FOR <span id="final-username" class="text-cyan-400">USER</span></p>
            
            <!-- 3D Object Container (Canvas handles rendering) -->
            <div class="w-64 h-64 border border-cyan-500/30 rounded-full relative flex items-center justify-center animate-pulse">
                <div class="absolute inset-0 bg-cyan-500/5 rounded-full blur-xl"></div>
                <span class="text-[10px] text-cyan-500/50 absolute bottom-4">ROTATING ARTIFACT</span>
            </div>

            <button class="mt-12 pointer-events-auto px-8 py-3 bg-white text-black font-bold rounded hover:bg-gray-200 transition-colors" onclick="location.reload()">
                SYSTEM REBOOT
            </button>
        </div>

    </div>

    <!-- Notification -->
    <div id="toast" class="fixed bottom-10 right-10 p-4 bg-black/80 border-l-4 border-cyan-500 text-cyan-400 font-mono text-sm transform translate-y-32 transition-transform duration-300 z-50">
        SYSTEM MESSAGE
    </div>

    <script>
        // --- CORE SYSTEM SETUP ---
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let phase = 0;
        let username = "";
        let particles = [];
        let mouse = { x: 0, y: 0, down: false };
        let animationId;

        // --- RESIZE HANDLER ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- MOUSE INPUT ---
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);

        // --- PARTICLE ENGINE ---
        class Particle {
            constructor(x, y, color = '#00f0ff') {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.color = color;
                this.size = Math.random() * 2 + 0.5;
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.9;
                this.ease = 0.1;
                this.active = true;
            }

            update(targetX, targetY) {
                // Return to origin or move to target
                const tx = targetX !== undefined ? targetX : this.originX;
                const ty = targetY !== undefined ? targetY : this.originY;

                const dx = tx - this.x;
                const dy = ty - this.y;
                
                this.x += dx * this.ease;
                this.y += dy * this.ease;

                // Mouse interaction (repel/attract based on phase)
                const mdx = mouse.x - this.x;
                const mdy = mouse.y - this.y;
                const dist = Math.sqrt(mdx*mdx + mdy*mdy);

                if (dist < 100) {
                    const force = (100 - dist) / 100;
                    const angle = Math.atan2(mdy, mdx);
                    if (phase === 0) { // Repel in crystal phase
                         this.x -= Math.cos(angle) * force * 5;
                         this.y -= Math.sin(angle) * force * 5;
                    }
                }
            }

            draw() {
                if(!this.active) return;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.size, this.size);
                ctx.fill();
            }
        }

        // --- PHASE 0: CRYSTAL ---
        let crystalAngle = 0;
        
        function initCrystal() {
            particles = [];
            const count = 400;
            for(let i=0; i<count; i++) {
                // Random point in sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 100 + Math.random() * 20;
                
                const x = width/2 + r * Math.sin(phi) * Math.cos(theta);
                const y = height/2 + r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi); // stored for 3d projection
                
                const p = new Particle(x, y, '#00f0ff');
                p.z = z; // custom prop
                p.phi = phi;
                p.theta = theta;
                p.r = r;
                particles.push(p);
            }
        }

        // --- PHASE 1: THE BANK & ORB ---
        let bankParticles = [];
        let orb = { x: 100, y: 0, r: 30, dragging: false };
        let bankDestroyed = false;

        function initBank() {
            particles = [];
            orb.y = height / 2;
            orb.x = width * 0.15; // Start left
            
            // Build Bank Shape (Rectangle + Triangle)
            const bx = width/2;
            const by = height/2;
            
            // Pillars
            for(let x=bx-100; x<=bx+100; x+=20) {
                for(let y=by-100; y<=by+100; y+=10) {
                     particles.push(new Particle(x, y, '#64748b')); // Grey
                }
            }
            // Roof
            for(let y=by-180; y<by-100; y+=10) {
                const w = (y - (by-180)) * 2.5;
                for(let x=bx-w; x<=bx+w; x+=10) {
                    particles.push(new Particle(x, y, '#64748b'));
                }
            }
        }

        // --- PHASE 3: THE CHAIN ---
        let chainBlocks = [];
        function initChain() {
            particles = []; // Clear old
            chainBlocks = [];
            const startX = width * 0.1;
            const centerY = height/2;
            const size = 80;
            const gap = 40;
            
            for(let i=0; i<10; i++) {
                chainBlocks.push({
                    x: startX + i*(size+gap),
                    y: centerY - size/2,
                    w: size, h: size,
                    id: i,
                    valid: true
                });
            }
        }

        // --- PHASE 4: CONSENSUS ---
        let nodes = [];
        let signals = [];
        function initConsensus() {
            nodes = [];
            for(let i=0; i<50; i++) {
                nodes.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    status: 'idle', // idle, verifying, confirmed
                    timer: 0
                });
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            ctx.clearRect(0, 0, width, height);

            // === PHASE 0: CRYSTAL ROTATION ===
            if (phase === 0) {
                crystalAngle += 0.01;
                particles.forEach(p => {
                    // 3D Rotation math
                    let x = p.r * Math.sin(p.phi) * Math.cos(p.theta + crystalAngle);
                    let z = p.r * Math.sin(p.phi) * Math.sin(p.theta + crystalAngle);
                    
                    // Projection
                    let scale = 300 / (300 + z);
                    p.x = width/2 + x * scale;
                    p.y = height/2 + p.r * Math.cos(p.phi) * scale;
                    p.size = 2 * scale;
                    p.active = true;
                    p.draw();
                });
            }

            // === PHASE 1: BANK GLITCH ===
            if (phase === 1) {
                // Update Orb (Draggable Logic)
                if (mouse.down) {
                    const dx = mouse.x - orb.x;
                    const dy = mouse.y - orb.y;
                    if (Math.sqrt(dx*dx + dy*dy) < orb.r * 2) orb.dragging = true;
                } else {
                    orb.dragging = false;
                    // Reset if not completed
                    if (!bankDestroyed && orb.x < width/2) {
                        orb.x += (width*0.15 - orb.x) * 0.1;
                    }
                }

                if (orb.dragging) {
                    orb.x = mouse.x;
                    orb.y = mouse.y;
                }

                // Check Collision with Bank (Center)
                if (!bankDestroyed && Math.abs(orb.x - width/2) < 150 && Math.abs(orb.y - height/2) < 150) {
                    bankDestroyed = true;
                    showToast("INTERMEDIARY FAILURE. DECENTRALIZING...", "error");
                    
                    // Explode Bank
                    particles.forEach(p => {
                        p.vx = (Math.random() - 0.5) * 20;
                        p.vy = (Math.random() - 0.5) * 20;
                        p.color = '#ff2a6d'; // Turn red
                    });
                    
                    setTimeout(() => {
                         // Transform to Grid
                         nextPhase();
                    }, 2000);
                }

                // Draw Bank Particles
                particles.forEach(p => {
                    if (bankDestroyed) {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.size = Math.random() * 3; // Glitch size
                    } else {
                        // Static jitter
                         p.x = p.originX + (Math.random()-0.5); 
                    }
                    p.draw();
                });

                // Draw Orb
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.r, 0, Math.PI * 2);
                ctx.fillStyle = '#00f0ff';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00f0ff';
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // === PHASE 2 (FORGE) & 5 (SC) ===
            if (phase === 2 || phase === 5) {
                // Just background particles floating
                if (particles.length === 0) {
                    for(let i=0; i<50; i++) particles.push(new Particle(Math.random()*width, Math.random()*height, '#0891b2'));
                }
                particles.forEach(p => {
                    p.y -= 0.5;
                    if(p.y < 0) p.y = height;
                    p.draw();
                });
            }

            // === PHASE 3: CHAIN ===
            if (phase === 3) {
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 4;
                
                // Draw Connections
                ctx.beginPath();
                ctx.moveTo(chainBlocks[0].x + 40, chainBlocks[0].y + 40);
                ctx.lineTo(chainBlocks[chainBlocks.length-1].x + 40, chainBlocks[chainBlocks.length-1].y + 40);
                ctx.stroke();

                // Draw Blocks
                chainBlocks.forEach(b => {
                    ctx.fillStyle = b.valid ? '#0f172a' : '#450a0a'; // Slate vs Red background
                    ctx.strokeStyle = b.valid ? '#00f0ff' : '#ff2a6d';
                    ctx.lineWidth = 2;
                    
                    // Draw rect
                    ctx.beginPath();
                    ctx.rect(b.x, b.y, b.w, b.h);
                    ctx.fill();
                    ctx.stroke();

                    // Text
                    ctx.fillStyle = 'white';
                    ctx.font = '12px monospace';
                    ctx.fillText('#' + b.id, b.x + 10, b.y + 20);
                    
                    // Handle Click (Hacking)
                    if (mouse.down && b.id === 5) { // Hack block 5
                        invalidateChainFrom(5);
                    }
                });
            }

            // === PHASE 4: CONSENSUS ===
            if (phase === 4) {
                // World Map Nodes
                nodes.forEach(n => {
                    if (n.status === 'idle') ctx.fillStyle = '#1e293b';
                    if (n.status === 'verifying') ctx.fillStyle = 'white';
                    if (n.status === 'confirmed') ctx.fillStyle = '#00f0ff';
                    
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, 4, 0, Math.PI*2);
                    ctx.fill();
                });

                // Signals
                signals.forEach((s, index) => {
                    s.r += 5;
                    ctx.strokeStyle = `rgba(0, 240, 255, ${1 - s.r/300})`;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
                    ctx.stroke();
                    
                    // Hit detection
                    nodes.forEach(n => {
                        const d = Math.sqrt((n.x-s.x)**2 + (n.y-s.y)**2);
                        if (Math.abs(d - s.r) < 10 && n.status === 'idle') {
                            n.status = 'verifying';
                            setTimeout(() => n.status = 'confirmed', Math.random()*1000 + 500);
                        }
                    });

                    if(s.r > 300) signals.splice(index, 1);
                });
            }
            
            // === PHASE 6: NFT ===
            if (phase === 6) {
                // Simple 3D Cube rotation
                crystalAngle += 0.02;
                ctx.strokeStyle = '#00f0ff';
                ctx.lineWidth = 2;
                
                const size = 100;
                const points = [
                    [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
                    [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
                ];
                
                const projected = points.map(p => {
                    // Rotate Y
                    let x = p[0]*Math.cos(crystalAngle) - p[2]*Math.sin(crystalAngle);
                    let z = p[0]*Math.sin(crystalAngle) + p[2]*Math.cos(crystalAngle);
                    // Rotate X
                    let y = p[1]*Math.cos(crystalAngle*0.5) - z*Math.sin(crystalAngle*0.5);
                    
                    let scale = 300 / (300 + z + 5);
                    return {
                        x: width/2 + x * size * scale,
                        y: height/2 + y * size * scale
                    };
                });
                
                // Draw Edges
                const edges = [
                    [0,1], [1,2], [2,3], [3,0], // back
                    [4,5], [5,6], [6,7], [7,4], // front
                    [0,4], [1,5], [2,6], [3,7]  // connecting
                ];
                
                ctx.beginPath();
                edges.forEach(e => {
                    ctx.moveTo(projected[e[0]].x, projected[e[0]].y);
                    ctx.lineTo(projected[e[1]].x, projected[e[1]].y);
                });
                ctx.stroke();
            }

            requestAnimationFrame(animate);
        }

        // --- GAMEPLAY FUNCTIONS ---

        const usernameInput = document.getElementById('username-input');
        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                username = usernameInput.value;
                document.getElementById('user-identity').innerText = username;
                document.getElementById('final-username').innerText = username;
                
                // EXPLOSION ANIMATION
                particles.forEach(p => {
                    p.vx = (Math.random() - 0.5) * 20;
                    p.vy = (Math.random() - 0.5) * 20;
                });
                
                // Transition
                setTimeout(() => nextPhase(), 1000);
            }
        });

        function pullLever() {
            const handle = document.getElementById('forge-lever');
            if (handle.classList.contains('pulled')) return;
            
            handle.classList.add('pulled');
            
            // Calc Hash
            setTimeout(() => {
                const hash = "0x" + Math.random().toString(16).substr(2, 64);
                document.getElementById('hash-display').innerText = hash;
                document.getElementById('hash-display').classList.add('text-green-400');
                showToast("BLOCK HASHED SUCCESSFULLY", "success");
                document.getElementById('phase-2-next').classList.remove('hidden');
            }, 500);
        }

        function breakHash() {
            const handle = document.getElementById('forge-lever');
            if (handle.classList.contains('pulled')) {
                 document.getElementById('hash-display').innerText = "INVALID_GEOMETRY_ERROR";
                 document.getElementById('hash-display').classList.replace('text-green-400', 'text-red-500');
                 handle.classList.remove('pulled');
                 showToast("DATA TAMPERED! HASH BROKEN.", "error");
            }
        }

        function invalidateChainFrom(index) {
            for(let i=index; i<chainBlocks.length; i++) {
                chainBlocks[i].valid = false;
            }
            showToast("HISTORIC MODIFICATION DETECTED. CHAIN COLLAPSED.", "error");
            document.getElementById('phase-3-next').classList.remove('hidden');
        }

        function broadcastBlock() {
            signals.push({x: width/2, y: height/2, r: 0});
            setTimeout(() => {
                 showToast("CONSENSUS REACHED (51%)", "success");
                 setTimeout(nextPhase, 2000);
            }, 3000);
        }

        function triggerSmartContract() {
            const signal = document.getElementById('sc-signal');
            const icon = document.getElementById('sc-lock-icon');
            const status = document.getElementById('sc-status');
            
            signal.classList.replace('w-0', 'w-full');
            
            setTimeout(() => {
                icon.classList.replace('text-red-500', 'text-green-500');
                icon.setAttribute('data-lucide', 'unlock');
                document.getElementById('sc-output').classList.replace('border-red-500', 'border-green-500');
                document.getElementById('sc-output').classList.replace('shadow-[0_0_15px_#ff2a6d]', 'shadow-[0_0_15px_#05ffa1]');
                status.innerText = "UNLOCKED";
                status.classList.add('text-green-400');
                lucide.createIcons();
                showToast("PAYMENT RECEIVED. FUNCTION EXECUTED.", "success");
                document.getElementById('phase-5-next').classList.remove('hidden');
            }, 1000);
        }

        function nextPhase() {
            // Hide current UI
            document.getElementById(`phase-${phase}`).classList.remove('active');
            
            phase++;
            document.getElementById('progress-bar').style.width = `${(phase/6)*100}%`;
            
            // Init next phase logic
            if(phase === 1) initBank();
            if(phase === 3) initChain();
            if(phase === 4) initConsensus();
            
            // Show new UI
            setTimeout(() => {
                const nextEl = document.getElementById(`phase-${phase}`);
                if(nextEl) nextEl.classList.add('active');
            }, 500);
        }

        function showToast(msg, type) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.borderColor = type === 'error' ? '#ff2a6d' : '#05ffa1';
            t.style.color = type === 'error' ? '#ff2a6d' : '#05ffa1';
            t.classList.remove('translate-y-32');
            setTimeout(() => t.classList.add('translate-y-32'), 3000);
        }

        // --- BOOT ---
        resize();
        initCrystal();
        animate();
        lucide.createIcons();

    </script>
</body>
</html>
